import { ref, onMounted, onUnmounted, watch } from 'vue';
import * as THREE from 'three';
import { FBXLoader } from 'three/addons/loaders/FBXLoader.js';
import { player, mapMonsters, mapPlayers, destinationMarker, currentMonster, addLog, selectedTargetId, isFreeFarming, pendingAttackId, inspectedPlayer, selectedMapId, currentMapData, mapNpcs } from '../state.js';
import { api } from '../services/api.js';
import { stopAutoFarm, checkAndAct } from '../services/autoFarm.js';

export default {
    emits: ['interact-npc'],
    template: `
        <div class="absolute top-14 bottom-0 w-full bg-gray-950 overflow-hidden">
            <!-- Map Info -->
            <div class="absolute top-4 left-4 text-xs text-gray-500 font-mono z-10 bg-black/50 px-2 py-1 rounded pointer-events-none">
                MAP: {{ formatMapName(player?.current_map_id) }} | {{ Math.round(player?.position?.x || 0) }}, {{ Math.round(player?.position?.y || 0) }}
            </div>

            <!-- 3D Container -->
            <div ref="container" class="w-full h-full cursor-crosshair block"></div>

            <!-- Entity Labels -->
            <div v-for="label in entityLabels" :key="label.id" 
                class="absolute pointer-events-none transform -translate-x-1/2 -translate-y-full flex flex-col items-center z-30"
                :style="{ left: label.x + 'px', top: label.y + 'px' }">
                <span class="text-[10px] font-bold shadow-black drop-shadow-md whitespace-nowrap"
                    :class="label.type === 'portal' ? 'text-cyan-300 text-xs tracking-wider bg-black/50 px-1 rounded' : (label.type === 'npc' ? 'text-yellow-300 text-xs bg-black/50 px-1 rounded' : (label.isPlayer ? 'text-green-300' : 'text-red-300'))">
                    {{ label.name }}
                </span>
                <div v-if="label.max_hp > 0" class="w-8 h-1 bg-gray-700 mt-0.5 rounded-full overflow-hidden border border-black/50">
                    <div class="h-full transition-all duration-300"
                        :class="label.isPlayer ? 'bg-green-500' : 'bg-red-500'"
                        :style="{ width: (label.hp / label.max_hp * 100) + '%' }"></div>
                </div>
            </div>

            <!-- Enemy Status Overlay -->
            <div v-if="currentMonster"
                class="absolute top-16 right-4 bg-gray-800 p-2 rounded border border-red-900 shadow-xl z-20 w-48 pointer-events-none">
                <div class="flex justify-between items-center mb-1">
                    <span class="font-bold text-red-400 text-xs truncate">{{ currentMonster.name }}</span>
                    <span class="text-xs text-gray-400">{{ currentMonster.hp }}/{{ currentMonster.max_hp }}</span>
                </div>
                <div class="w-full bg-gray-700 rounded-full h-2 overflow-hidden">
                    <div class="bg-red-600 h-full transition-all duration-300"
                        :style="{ width: (currentMonster.hp / currentMonster.max_hp * 100) + '%' }"></div>
                </div>
            </div>

            <!-- Auto Attack Toggle Button -->
            <div class="absolute bottom-24 left-4 z-50 pointer-events-auto">
                <button @click="toggleAutoAttack" 
                    class="flex items-center gap-2 px-4 py-2 rounded-full font-bold text-white shadow-lg border-2 transition-all text-xs"
                    :class="isFreeFarming ? 'bg-red-600 border-red-400 hover:bg-red-500' : 'bg-green-600 border-green-400 hover:bg-green-500'">
                    <span>{{ isFreeFarming ? 'Stop Auto (Space)' : 'Start Auto (Space)' }}</span>
                </button>
            </div>
            
            <!-- Interaction Button -->
            <div v-if="(canEnterPortal || canInteractNpc) && !isFreeFarming" class="absolute bottom-24 left-1/2 transform -translate-x-1/2 z-50 flex flex-col gap-2 items-center">
                <button v-if="canEnterPortal" @click="confirmPortal" class="bg-blue-600 hover:bg-blue-500 text-white font-bold py-2 px-6 rounded-full shadow-lg border-2 border-blue-400 animate-bounce">
                    Enter Portal (F)
                </button>
                <button v-if="canInteractNpc" @click="interactNpc" class="bg-yellow-600 hover:bg-yellow-500 text-white font-bold py-2 px-6 rounded-full shadow-lg border-2 border-yellow-400 animate-bounce">
                    Talk to {{ closestNpc?.name }} (F)
                </button>
            </div>
            
            <!-- FPS Counter -->
            <div class="absolute top-0 right-0 bg-black/50 text-green-400 font-mono text-xs px-2 py-1 pointer-events-none">
                FPS: {{ fps }}
            </div>
        </div>
    `,
    setup(props, { emit }) {
        const container = ref(null);
        const fps = ref(0);
        const canEnterPortal = ref(false);
        const pendingPortal = ref(null);
        const canInteractNpc = ref(false);
        const closestNpc = ref(null);
        const entityLabels = ref([]);

        // Three.js variables
        let scene, camera, renderer, raycaster, mouse;
        let groundPlane;
        let animationId;

        // Entity Meshes Map: ID -> Mesh
        const meshes = new Map();

        // --- ANIMATION SYSTEM ---
        const fbxLoader = new FBXLoader();
        const clock = new THREE.Clock();
        const mixers = [];
        const playerAnims = {};
        let playerMixer = null;
        let currentAction = null;
        let isModelLoading = false;

        const loadPlayerModel = (playerData, material) => {
            const group = new THREE.Group();
            group.userData = { type: 'player', entity: playerData };

            // Add Placeholder
            const placeholder = new THREE.Mesh(geometries.player, material);
            placeholder.castShadow = true;
            group.add(placeholder);

            const basePath = `/characters/${playerData.p_class.toLowerCase()}`;

            fbxLoader.load(`${basePath}/idle.fbx`, (object) => {
                // Remove placeholder
                group.remove(placeholder);

                // Process Model
                object.traverse(child => {
                    if (child.isMesh) {
                        child.castShadow = true;
                        child.receiveShadow = true;
                    }
                });

                // Scale (Auto-fit to height ~2.5)
                const box = new THREE.Box3().setFromObject(object);
                const size = box.getSize(new THREE.Vector3());
                const scale = 2.5 / size.y;
                object.scale.set(scale, scale, scale);
                object.position.y = -1;

                // Rotate 180 (Models often face +Z, we want -Z or consistent)
                // object.rotation.y = Math.PI;

                group.add(object);

                // Setup Mixer
                const mixer = new THREE.AnimationMixer(object);
                playerMixer = mixer;
                mixers.push(mixer);

                // Idle Action
                if (object.animations.length > 0) {
                    const action = mixer.clipAction(object.animations[0]);
                    playerAnims.idle = action;
                    action.play();
                    currentAction = action;
                }

                // Load Run
                fbxLoader.load(`${basePath}/running.fbx`, (anim) => {
                    if (anim.animations.length > 0) playerAnims.run = mixer.clipAction(anim.animations[0]);
                });

                // Load Attack
                fbxLoader.load(`${basePath}/attack1.fbx`, (anim) => {
                    if (anim.animations.length > 0) {
                        const action = mixer.clipAction(anim.animations[0]);
                        action.loop = THREE.LoopOnce;
                        // action.clampWhenFinished = true;
                        playerAnims.attack = action;

                        mixer.addEventListener('finished', (e) => {
                            if (e.action === playerAnims.attack) {
                                // Reset to Idle/Run handled in animate loop
                                // playerAnims.attack.stop();
                            }
                        });
                    }
                });
            }, undefined, (error) => {
                console.error("Failed to load model:", error);
            });

            return group;
        };

        const keys = { w: false, a: false, s: false, d: false };
        let lastMoveTime = 0;

        const formatMapName = (id) => {
            if (!id) return '';
            return id.replace('map_', '').replace('_', ' ').toUpperCase();
        };

        // Shared Resources
        const geometries = {
            player: null,
            monster: null,
            portal: null,
            npc: null
        };
        const materials = {
            player: null,
            otherPlayer: null,
            monster: null,
            npc: null
        };

        const initThree = () => {
            const width = container.value.clientWidth;
            const height = container.value.clientHeight;

            // Initialize Shared Geometries/Materials
            geometries.player = new THREE.BoxGeometry(1, 2, 1);
            geometries.monster = new THREE.CylinderGeometry(0.5, 0.5, 1.5, 16);
            geometries.portal = new THREE.TorusGeometry(1, 0.2, 8, 16);
            geometries.npc = new THREE.CylinderGeometry(0.5, 0.5, 2, 8);

            materials.player = new THREE.MeshStandardMaterial({ color: 0x22c55e });
            materials.otherPlayer = new THREE.MeshStandardMaterial({ color: 0x3b82f6 });
            materials.monster = new THREE.MeshStandardMaterial({ color: 0xef4444 });
            materials.npc = new THREE.MeshStandardMaterial({ color: 0xfacc15 });

            // 1. Scene
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x111827); // Dark gray background

            // 2. Camera (Orthographic for Isometric)
            const aspect = width / height;
            const d = 20; // View size
            camera = new THREE.OrthographicCamera(-d * aspect, d * aspect, d, -d, 1, 1000);

            // Isometric Angle: Look from corner
            camera.position.set(20, 20, 20);
            camera.lookAt(scene.position); // Will be updated to follow player

            // 3. Renderer
            renderer = new THREE.WebGLRenderer({ antialias: true, powerPreference: "high-performance" });
            renderer.setSize(width, height);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap; // Softer shadows
            container.value.appendChild(renderer.domElement);

            // Force initial resize to ensure correct dimensions
            onWindowResize();

            // 4. Lights
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);

            const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
            dirLight.position.set(50, 50, 0);
            dirLight.castShadow = true;
            dirLight.shadow.mapSize.width = 1024;
            dirLight.shadow.mapSize.height = 1024;
            dirLight.shadow.camera.left = -50;
            dirLight.shadow.camera.right = 50;
            dirLight.shadow.camera.top = 50;
            dirLight.shadow.camera.bottom = -50;
            scene.add(dirLight);

            // 5. Ground
            const geometry = new THREE.PlaneGeometry(100, 100);
            const material = new THREE.MeshStandardMaterial({
                color: 0x1f2937,
                side: THREE.DoubleSide
            });
            groundPlane = new THREE.Mesh(geometry, material);
            groundPlane.rotation.x = -Math.PI / 2; // Lay flat
            groundPlane.position.set(50, 0, 50); // Center at 50,50 (Game coords 0-100)
            groundPlane.receiveShadow = true;
            scene.add(groundPlane);

            // Grid Helper
            const gridHelper = new THREE.GridHelper(100, 10, 0x374151, 0x374151);
            gridHelper.position.set(50, 0.01, 50); // Slightly above ground
            scene.add(gridHelper);

            // 6. Raycaster
            raycaster = new THREE.Raycaster();
            mouse = new THREE.Vector2();

            // Event Listeners
            window.addEventListener('resize', onWindowResize);
            container.value.addEventListener('click', onMouseClick);
        };

        const onWindowResize = () => {
            if (!container.value) return;
            const width = container.value.clientWidth;
            const height = container.value.clientHeight;
            const aspect = width / height;
            const d = 20;

            camera.left = -d * aspect;
            camera.right = d * aspect;
            camera.top = d;
            camera.bottom = -d;
            camera.updateProjectionMatrix();
            renderer.setSize(width, height);
        };

        const onMouseClick = async (event) => {
            if (!player.value) return;

            // Calculate mouse position in normalized device coordinates
            const rect = renderer.domElement.getBoundingClientRect();
            mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
            mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;

            raycaster.setFromCamera(mouse, camera);

            // Check intersections
            const intersects = raycaster.intersectObjects(scene.children);

            for (let i = 0; i < intersects.length; i++) {
                const obj = intersects[i].object;

                // Check if clicked a Monster
                if (obj.userData.type === 'monster') {
                    const m = obj.userData.entity;
                    if (m.hp > 0) {
                        addLog(`Moving to attack ${m.name}...`);
                        stopAutoFarm();

                        // Set current monster for UI
                        currentMonster.value = m;
                        selectedTargetId.value = m.template_id;
                        selectedMapId.value = player.value.current_map_id;

                        // Don't enable auto-farm on manual click, just attack this specific target
                        isFreeFarming.value = false;

                        // Move towards monster (0 distance)
                        const angle = Math.atan2(m.position_y - player.value.position.y, m.position_x - player.value.position.x);
                        const stopDist = 0;
                        const targetX = m.position_x - Math.cos(angle) * stopDist;
                        const targetY = m.position_y - Math.sin(angle) * stopDist;

                        await api.movePlayer(player.value.current_map_id, targetX, targetY);
                        destinationMarker.value = { x: targetX, y: targetY, isGameCoords: true };
                        setTimeout(() => destinationMarker.value = null, 500);
                        pendingAttackId.value = m.id;
                        return;
                    }
                }

                // Check if clicked Ground
                if (obj === groundPlane) {
                    const point = intersects[i].point;
                    const gameX = point.x;
                    const gameY = point.z; // Z is Y in 2D

                    stopAutoFarm();
                    destinationMarker.value = { x: gameX, y: gameY, time: Date.now(), isGameCoords: true };
                    api.movePlayer(player.value.current_map_id, gameX, gameY);

                    setTimeout(() => destinationMarker.value = null, 500);
                    return;
                }
            }
        };

        const updateEntities = () => {
            const validIds = new Set();
            const LERP_FACTOR = 0.15; // Smoothness factor

            // 1. Local Player
            if (player.value) {
                const pid = player.value.id;
                validIds.add(pid);
                let mesh = meshes.get(pid);
                if (!mesh) {
                    if (player.value.p_class.toLowerCase() === 'warrior') {
                        mesh = loadPlayerModel(player.value, materials.player);
                    } else {
                        mesh = new THREE.Mesh(geometries.player, materials.player);
                        mesh.castShadow = true;
                        mesh.userData = { type: 'player', entity: player.value };
                    }
                    mesh.position.set(player.value.position.x, 1, player.value.position.y);
                    scene.add(mesh);
                    meshes.set(pid, mesh);
                }
                mesh.userData.entity = player.value;

                // Interpolate Position & Rotation
                const targetX = player.value.position.x;
                const targetZ = player.value.position.y;

                // Calculate movement direction for rotation
                const dx = targetX - mesh.position.x;
                const dz = targetZ - mesh.position.z;

                if (Math.abs(dx) > 0.1 || Math.abs(dz) > 0.1) {
                    const angle = Math.atan2(dx, dz);
                    mesh.rotation.y = angle;
                }

                const dist = Math.sqrt(dx * dx + dz * dz);

                if (dist > 10) {
                    mesh.position.x = targetX;
                    mesh.position.z = targetZ;
                    camera.position.x = targetX + 20;
                    camera.position.z = targetZ + 20;
                    camera.lookAt(targetX, 0, targetZ);
                } else {
                    mesh.position.x += (targetX - mesh.position.x) * LERP_FACTOR;
                    mesh.position.z += (targetZ - mesh.position.z) * LERP_FACTOR;

                    // Camera Follow (Smooth)
                    const targetCamX = mesh.position.x + 20;
                    const targetCamZ = mesh.position.z + 20;
                    camera.position.x += (targetCamX - camera.position.x) * LERP_FACTOR;
                    camera.position.z += (targetCamZ - camera.position.z) * LERP_FACTOR;
                    camera.lookAt(camera.position.x - 20, 0, camera.position.z - 20);
                }
            }

            // 2. Other Players
            mapPlayers.value.forEach(p => {
                if (p.id === player.value.id) return;
                validIds.add(p.id);
                let mesh = meshes.get(p.id);
                if (!mesh) {
                    mesh = new THREE.Mesh(geometries.player, materials.otherPlayer);
                    mesh.castShadow = true;
                    mesh.userData = { type: 'player', entity: p };
                    mesh.position.set(p.position.x, 1, p.position.y);
                    scene.add(mesh);
                    meshes.set(p.id, mesh);
                }
                // Interpolate
                const targetX = p.position.x;
                const targetZ = p.position.y;
                if (Math.abs(targetX - mesh.position.x) > 10 || Math.abs(targetZ - mesh.position.z) > 10) {
                    mesh.position.x = targetX;
                    mesh.position.z = targetZ;
                } else {
                    mesh.position.x += (targetX - mesh.position.x) * LERP_FACTOR;
                    mesh.position.z += (targetZ - mesh.position.z) * LERP_FACTOR;
                }
            });

            // 3. Monsters
            mapMonsters.value.forEach(m => {
                if (!m.stats || m.stats.hp <= 0) return;
                validIds.add(m.id);
                let mesh = meshes.get(m.id);
                if (!mesh) {
                    mesh = new THREE.Mesh(geometries.monster, materials.monster);
                    mesh.castShadow = true;
                    mesh.userData = { type: 'monster', entity: m };
                    mesh.position.set(m.position_x, 0.75, m.position_y);
                    scene.add(mesh);
                    meshes.set(m.id, mesh);
                }
                // Interpolate
                const targetX = m.position_x;
                const targetZ = m.position_y;
                if (Math.abs(targetX - mesh.position.x) > 10 || Math.abs(targetZ - mesh.position.z) > 10) {
                    mesh.position.x = targetX;
                    mesh.position.z = targetZ;
                } else {
                    mesh.position.x += (targetX - mesh.position.x) * LERP_FACTOR;
                    mesh.position.z += (targetZ - mesh.position.z) * LERP_FACTOR;
                }

                mesh.userData.entity = m;
            });

            // 4. Portals
            if (currentMapData.value && currentMapData.value.portals) {
                currentMapData.value.portals.forEach(portal => {
                    const pid = `portal_${portal.id}`;
                    validIds.add(pid);
                    let mesh = meshes.get(pid);
                    if (!mesh) {
                        const mat = new THREE.MeshStandardMaterial({ color: portal.color || 0xffffff, emissive: portal.color || 0x000000, emissiveIntensity: 0.5 });
                        mesh = new THREE.Mesh(geometries.portal, mat);
                        mesh.rotation.x = 0;
                        mesh.position.set(portal.x, 1, portal.y);
                        mesh.userData = { type: 'portal', entity: { name: portal.label || 'Portal', hp: 0, max_hp: 0 } };
                        scene.add(mesh);
                        meshes.set(pid, mesh);
                    }
                    // Rotate portal effect
                    mesh.rotation.y += 0.02;
                });
            }

            // 5. NPCs
            if (mapNpcs.value) {
                mapNpcs.value.forEach(npc => {
                    validIds.add(npc.id);
                    let mesh = meshes.get(npc.id);
                    if (!mesh) {
                        mesh = new THREE.Mesh(geometries.npc, materials.npc);
                        mesh.castShadow = true;
                        mesh.userData = { type: 'npc', entity: npc };
                        mesh.position.set(npc.x, 1, npc.y);
                        scene.add(mesh);
                        meshes.set(npc.id, mesh);
                    }
                    mesh.position.set(npc.x, 1, npc.y);
                });
            }

            // 6. Cleanup
            for (const [id, mesh] of meshes) {
                if (!validIds.has(id)) {
                    scene.remove(mesh);
                    // Only dispose material if it's a portal (custom)
                    if (id.toString().startsWith('portal_')) {
                        mesh.material.dispose();
                    }
                    // Do NOT dispose shared geometries/materials
                    meshes.delete(id);
                }
            }
        };

        const updateMovement = () => {
            if (!player.value) return;
            const now = Date.now();
            if (now - lastMoveTime < 100) return; // Throttle 100ms

            let dx = 0;
            let dy = 0;
            if (keys.w) dy -= 1;
            if (keys.s) dy += 1;
            if (keys.a) dx -= 1;
            if (keys.d) dx += 1;

            if (dx !== 0 || dy !== 0) {
                stopAutoFarm();
                isFreeFarming.value = false;

                // Normalize vector
                const len = Math.sqrt(dx * dx + dy * dy);
                dx /= len;
                dy /= len;

                const dist = 5;
                const targetX = player.value.position.x + dx * dist;
                const targetY = player.value.position.y + dy * dist;

                api.movePlayer(player.value.current_map_id, targetX, targetY);
                lastMoveTime = now;
            }
        };

        const checkInteractions = () => {
            if (!player.value || !currentMapData.value) return;
            const p = player.value.position;

            // Portals
            let closestDist = 999;
            let closestPortal = null;

            if (currentMapData.value.portals) {
                for (const portal of currentMapData.value.portals) {
                    const dist = Math.sqrt((p.x - portal.x) ** 2 + (p.y - portal.y) ** 2);
                    if (dist < closestDist) {
                        closestDist = dist;
                        closestPortal = portal;
                    }
                }
            }

            if (closestPortal && closestDist < 4.0) {
                pendingPortal.value = {
                    name: closestPortal.label || 'Portal',
                    targetMap: closestPortal.target_map_id,
                    x: closestPortal.target_x,
                    y: closestPortal.target_y
                };
                canEnterPortal.value = true;
                if (isFreeFarming.value) confirmPortal();
            } else {
                canEnterPortal.value = false;
                pendingPortal.value = null;
            }

            // NPCs
            let closestNpcDist = 999;
            let targetNpc = null;

            if (mapNpcs.value) {
                for (const npc of mapNpcs.value) {
                    const dist = Math.sqrt((p.x - npc.x) ** 2 + (p.y - npc.y) ** 2);
                    if (dist < closestNpcDist) {
                        closestNpcDist = dist;
                        targetNpc = npc;
                    }
                }
            }

            if (targetNpc && closestNpcDist < 3.0) {
                closestNpc.value = targetNpc;
                canInteractNpc.value = true;
            } else {
                closestNpc.value = null;
                canInteractNpc.value = false;
            }
        };

        const confirmPortal = async () => {
            if (pendingPortal.value) {
                await api.movePlayer(pendingPortal.value.targetMap, pendingPortal.value.x, pendingPortal.value.y);
                canEnterPortal.value = false;
            }
        };

        const interactNpc = () => {
            if (closestNpc.value) {
                emit('interact-npc', closestNpc.value);
            }
        };

        const toggleAutoAttack = () => {
            if (isFreeFarming.value) {
                stopAutoFarm();
                addLog("Auto Attack Disabled", "text-red-400");
            } else {
                // Sync selected map to current map so we farm HERE
                if (player.value) {
                    selectedMapId.value = player.value.current_map_id;
                }
                // Clear specific target so we attack anything nearby
                selectedTargetId.value = null;

                isFreeFarming.value = true;
                checkAndAct();
                addLog("Auto Attack Enabled", "text-green-400");
            }
        };

        const handleKeyDown = (e) => {
            if (e.key === 'w' || e.key === 'W') keys.w = true;
            if (e.key === 'a' || e.key === 'A') keys.a = true;
            if (e.key === 's' || e.key === 'S') keys.s = true;
            if (e.key === 'd' || e.key === 'D') keys.d = true;
            if (e.key === 'f' || e.key === 'F') {
                if (canEnterPortal.value) confirmPortal();
                else if (canInteractNpc.value) interactNpc();
            }
            if (e.key === ' ') {
                toggleAutoAttack();
            }
        };

        const handleKeyUp = (e) => {
            if (e.key === 'w' || e.key === 'W') keys.w = false;
            if (e.key === 'a' || e.key === 'A') keys.a = false;
            if (e.key === 's' || e.key === 'S') keys.s = false;
            if (e.key === 'd' || e.key === 'D') keys.d = false;
        };

        const tempVec = new THREE.Vector3();

        const toScreenPosition = (obj) => {
            if (!container.value) return { x: 0, y: 0 };

            obj.updateMatrixWorld();
            tempVec.setFromMatrixPosition(obj.matrixWorld);

            // Offset based on type
            const offset = obj.userData.type === 'player' ? 2.5 : (obj.userData.type === 'portal' ? 3.0 : (obj.userData.type === 'npc' ? 2.5 : 2.0));
            tempVec.y += offset;

            tempVec.project(camera);

            const widthHalf = 0.5 * container.value.clientWidth;
            const heightHalf = 0.5 * container.value.clientHeight;

            return {
                x: (tempVec.x * widthHalf) + widthHalf,
                y: -(tempVec.y * heightHalf) + heightHalf
            };
        };

        let frameCount = 0;
        let lastFpsTime = performance.now();
        let lastLabelUpdate = 0;

        const animate = () => {
            animationId = requestAnimationFrame(animate);

            // Update Animations
            const delta = clock.getDelta();
            mixers.forEach(m => m.update(delta));

            // State Machine for Player Animation
            if (playerMixer && player.value && playerAnims.idle) {
                let desired = playerAnims.idle;

                const state = (player.value.state || 'idle').toUpperCase();

                if (state === 'MOVING' && playerAnims.run) desired = playerAnims.run;
                else if (state === 'COMBAT' && playerAnims.attack) desired = playerAnims.attack;

                if (desired && desired !== currentAction) {
                    if (currentAction) currentAction.fadeOut(0.2);
                    desired.reset().fadeIn(0.2).play();
                    currentAction = desired;
                }
            }

            updateMovement();
            checkInteractions();
            updateEntities();

            renderer.render(scene, camera);

            // FPS
            const now = performance.now();
            frameCount++;
            if (now - lastFpsTime >= 1000) {
                fps.value = frameCount;
                frameCount = 0;
                lastFpsTime = now;
            }

            // Update Labels (Every frame for smoothness)
            const labels = [];
            for (const [id, mesh] of meshes) {
                if (!mesh.visible) continue;

                const pos = toScreenPosition(mesh);
                // Check if on screen (simple bounds check could optimize further)
                if (pos.x < -50 || pos.x > container.value.clientWidth + 50 ||
                    pos.y < -50 || pos.y > container.value.clientHeight + 50) continue;

                const entity = mesh.userData.entity;
                if (entity) {
                    labels.push({
                        id: id,
                        x: Math.round(pos.x),
                        y: Math.round(pos.y),
                        name: entity.name,
                        hp: entity.stats ? entity.stats.hp : (entity.hp || 0),
                        max_hp: entity.stats ? entity.stats.max_hp : (entity.max_hp || 0),
                        type: mesh.userData.type,
                        isPlayer: mesh.userData.type === 'player'
                    });
                }
            }
            entityLabels.value = labels;
        };

        watch(() => player.value?.current_map_id, async (newMapId) => {
            if (newMapId) {
                stopAutoFarm();
                await api.fetchMapMonsters(newMapId);
                api.fetchMapPlayers(newMapId);

                // Fetch NPCs
                try {
                    const res = await fetch(`http://localhost:8000/map/${newMapId}/npcs`);
                    if (res.ok) mapNpcs.value = await res.json();
                } catch (e) { console.error(e); }

                try {
                    const res = await fetch(`http://localhost:8000/map/${newMapId}`);
                    if (res.ok) currentMapData.value = await res.json();
                } catch (e) { console.error(e); }
            }
        }, { immediate: true });

        onMounted(() => {
            // Wait for next tick/timeout to ensure container has dimensions
            setTimeout(() => {
                initThree();
                animate();
            }, 100);

            window.addEventListener('keydown', handleKeyDown);
            window.addEventListener('keyup', handleKeyUp);
            if (player.value?.current_map_id) {
                api.fetchMapMonsters(player.value.current_map_id);
                api.fetchMapPlayers(player.value.current_map_id);
            }
        });

        onUnmounted(() => {
            cancelAnimationFrame(animationId);
            window.removeEventListener('resize', onWindowResize);
            window.removeEventListener('keydown', handleKeyDown);
            window.removeEventListener('keyup', handleKeyUp);
            if (renderer) {
                renderer.dispose();
                container.value.removeChild(renderer.domElement);
            }
        });

        return {
            container,
            player,
            currentMonster,
            formatMapName,
            canEnterPortal,
            confirmPortal,
            isFreeFarming,
            fps,
            entityLabels,
            toggleAutoAttack,
            canInteractNpc,
            closestNpc,
            interactNpc
        };
    }
};
